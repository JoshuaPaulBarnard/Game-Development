WEBVTT

1
00:00:17.490 --> 00:00:24.330
Welcome to Week 11 of game development, we are moving right along. And we finally covered

2
00:00:25.350 --> 00:00:29.850
Well, just so much territory. It's time for a little review and

3
00:00:30.990 --> 00:00:44.460
A little quiz and midterm exam on the world of JavaScript and the Fraser JS game engine. I'll talk about that this week and also look ahead to where we're headed for the remainder of the semester together.

4
00:00:48.030 --> 00:00:51.510
Have just a handful of small concepts to share with you that

5
00:00:52.830 --> 00:00:56.280
Need to filter into your brain as you kind of

6
00:00:57.480 --> 00:01:00.510
Wrap up the majority of rethinking about how Fazer works.

7
00:01:01.890 --> 00:01:02.850
Pair for the midterm.

8
00:01:04.470 --> 00:01:14.430
This week, so this week, we've got two major things to accomplish in week 11 do some review and tackle the midterm exam.

9
00:01:15.930 --> 00:01:26.160
part one. Part two is think about the game that you'd like to build for the rest of the semester and prepare a brief design document a brief narrative.

10
00:01:26.700 --> 00:01:32.250
About the game that you want to create. It's a proposal. It's a pitch, if you will.

11
00:01:33.180 --> 00:01:41.970
Next week, I will show a handful of additional advanced topics things that we can do, particularly around object oriented programming.

12
00:01:42.420 --> 00:01:53.370
In JavaScript, the Fazer engine lends itself to the development of object based game coding. We have stayed away from that for

13
00:01:53.820 --> 00:02:00.960
The majority of the semester today to make our class more accessible to people that are new to coding, we focused on procedural coding

14
00:02:01.350 --> 00:02:13.080
styles that use simple functions to capture all the code that we need to group together to tackle the various states in the face or game engine. Next week we'll look at developing what

15
00:02:13.860 --> 00:02:20.850
Phase or developers like to call prefabs which are basically sub classes of sprites that are designed specifically for their purpose.

16
00:02:21.630 --> 00:02:41.640
Will also look at using an advanced build system in a cloud nine workspace in a server workspace that can build that can transpire, if you will, will learn about that word more next week, the JavaScript code that we might save in separate files into a consolidated application.

17
00:02:42.810 --> 00:02:46.560
And then we'll really kick into building the final game.

18
00:02:49.740 --> 00:02:55.710
This week there's just a little bit more in the phase or chapter six, we're pretty much wrapping up chapter six. This week, put a

19
00:02:56.940 --> 00:03:16.140
put a bow on it and move on so that we can talk about other topics and chapters 122 through 130 to tackle the remaining topics that I'm going to scratch the surface of today, and then I'll pick up after the midterm with more focus in more detail for y'all.

20
00:03:19.230 --> 00:03:24.300
Terms of software this week. Well, there is no new coding project do this week.

21
00:03:25.050 --> 00:03:34.110
So I've got my default software. This week slide up here, but really what you're probably going to use this week as a word processor, whether it's Google Docs or Microsoft Word or whatever.

22
00:03:34.560 --> 00:03:46.110
Text Editor you like to meet documents in you'll be building a text based document to describe your game project idea as a game design document.

23
00:03:49.770 --> 00:04:04.740
And again, our focus is on Fazer although this week. We're also going to start looking at another game engine is extra credit for folks that are interested in have the bandwidth to tackle more material, we'll start talking about Unity 3D this week.

24
00:04:09.870 --> 00:04:27.510
So three things I want to say just a little bit about today and I do have a code demo for the first one that I'll share with you a few advanced Fazer concepts Fazer supports the ability to generate animated game objects that are not sprites.

25
00:04:29.160 --> 00:04:33.420
It's designed really to deal with these things that we call particles in a particle system.

26
00:04:35.370 --> 00:04:40.740
As a group entity. We don't really have individual access to particles in a particle system.

27
00:04:41.190 --> 00:04:56.880
But we can define what's known as an emitter, which is basically the thing that outputs the particles, you might think about it as well. A fire emits flames. Your sparkler in the Fourth of July parade that you're in mid sparks.

28
00:04:59.700 --> 00:05:09.240
Those are the kinds of things that particle systems are really good at emulating fire smoke sparks the flame coming out of a spaceship engine.

29
00:05:11.400 --> 00:05:16.530
Some Coins popping out of a treasure chest. When the reward is accomplished.

30
00:05:17.820 --> 00:05:27.180
And particle systems exist, mostly because of the taxing amount of math and computations that regular game objects like sprites have to go through

31
00:05:28.530 --> 00:05:32.850
Really limits our ability to introduce a huge number of objects into a game.

32
00:05:34.050 --> 00:05:34.710
So,

33
00:05:36.180 --> 00:05:39.930
That's really part of a theme today about handling.

34
00:05:41.190 --> 00:05:49.050
The computing capacity in Fazer in your web browser optimizing your code to deal with it particles are one aspect of that.

35
00:05:51.000 --> 00:05:56.010
Another topic that. Well, I think we already encountered last week, pretty much.

36
00:05:57.360 --> 00:06:04.200
Is the idea of signals and a sequel as a way to set aside and Fazer an event that should trigger a function that you've written

37
00:06:04.680 --> 00:06:18.570
Like when things collide and P to physics we can associate a signal function that runs when the collision happens or we can do that too with user events like mouse clicks. So signals are an advanced feature if these are let us

38
00:06:20.280 --> 00:06:26.910
Wind our function into the game engine so that it's executed automatically when a particular event happens

39
00:06:28.050 --> 00:06:31.050
And then finally, really just to introduce the idea

40
00:06:32.460 --> 00:06:37.080
Of object oriented programming to our Fazer game pattern coding

41
00:06:38.100 --> 00:06:56.340
say a little bit about prefabs today. And these are really classes of phase or objects, particularly the sprite object where we can basically make a custom sprite that has particular behaviors built into methods of its class or sub classes the case may be.

42
00:06:57.420 --> 00:07:00.420
And in our coming modules will look at this in more depth.

43
00:07:07.110 --> 00:07:14.220
In my code demo today I'll work with particles and I'll show you how those work I do have a handful of other

44
00:07:15.630 --> 00:07:26.670
Fundamental features of the phase or engine, I'd like you to know about that kind of like particle systems lend themselves to speedy game execution.

45
00:07:28.410 --> 00:07:33.630
One of these is the ability to instantly. Take a phase or sprite out of gameplay.

46
00:07:34.800 --> 00:07:41.550
Every sprite has a property, known as exists, and we can remove a game immediately from

47
00:07:43.140 --> 00:07:48.360
An object immediately from the game just by setting the exist property to false.

48
00:07:49.470 --> 00:07:59.100
So if exist is true the sprite is in the game world. It's available in phase or updates all of its calculations in each update game loop.

49
00:07:59.640 --> 00:08:10.050
For that sprite. As soon as the phase, phase or sprite does not exist by setting its exists property to false. We get rid of all that energy that Fazer might spend

50
00:08:11.700 --> 00:08:18.960
On managing the sprite and this exists property plays in to this concept known as object pooling

51
00:08:20.070 --> 00:08:37.560
And I have an article this week in the linked materials in Canvas that talks about object pooling in Fazer and I think this fellow does a really good job melky be as his site is called of explaining the purpose of object pooling

52
00:08:39.750 --> 00:08:50.280
If we've got a lot of objects that we're creating and deleting like enemy sprites, a huge amount of memory is being used and disposed of inside the browser.

53
00:08:50.940 --> 00:08:59.880
And literally the Fazer engine and the browser's JavaScript interpreter can really be dragged down to a very slow processing.

54
00:09:00.390 --> 00:09:12.780
Frame rate. If we have too much memory being created and allocated and then released and that's where object cooling is useful. We create a bunch of sprites in advance.

55
00:09:13.590 --> 00:09:22.950
And we deactivate or kill them and Fazer speak and then reactivate or reset them when we want to reuse them. It's like having a huge cast

56
00:09:23.400 --> 00:09:36.930
Of extras or characters in your screenplay, or your stage drama and instead of going out and hiring new actors off the street, every time you need somebody to come on stage, you keep them backstage waiting off screen.

57
00:09:37.410 --> 00:09:41.730
to reactivate them when it's time for them to come on stage and do their bit

58
00:09:46.410 --> 00:09:48.120
This is a very common.

59
00:09:49.530 --> 00:09:54.000
Pattern of coding Fazer and many game engines that idea that we create a

60
00:09:54.630 --> 00:10:06.570
large cast of sprites that we keep off screen and bring them on screen when we need them. The memories already been allocated for these sprites, they're already occupying space in the browser's brain, if you will.

61
00:10:07.080 --> 00:10:21.000
And we're not deleting inserting them instead we're just saying, Okay, come into the game world now leave the game world now and a great way to do this is to use a group. So in this example, we've got a group added to our game.

62
00:10:23.340 --> 00:10:30.360
Again, he's using arcade physics. So he enabled the body and set the physics body type on that group and then basically in a loop.

63
00:10:32.010 --> 00:10:37.290
He goes through and makes an instance of a sprite.

64
00:10:38.730 --> 00:10:57.990
And then he kills it. And then he stores it in this pool that he can reuse later on. And when he's ready so kill is a way of deactivating a sprite, but keeping it in the pool and reset is a way of bringing that sprite back on stage at a particular coordinate x and y.

65
00:10:59.460 --> 00:11:10.200
This is, I don't know, making a bunch of sprites killing them by taking them off stage and then resetting them as you need them to bring them on stage that yields a performance benefit.

66
00:11:12.390 --> 00:11:16.710
We can use exists with this pattern, along with kill and reset.

67
00:11:18.510 --> 00:11:29.130
So the kill method removes the sprite from the game, but it preserves it in memory. It's no longer visible, the game loop is not going to concern itself with processing the calculations for that sprite.

68
00:11:29.550 --> 00:11:39.300
As long as it's killed, but as soon as we use reset, we can bring that game that sprite that game object back into our game at a particular coordinate

69
00:11:41.010 --> 00:11:47.640
So normally, we'd have an x and y coordinate with reset to reintroduce it onto the stage.

70
00:11:51.960 --> 00:12:03.810
Another way to manage sprites and the time that they're available in the game world is through a property, known as lifespan. It's like setting a future.

71
00:12:04.530 --> 00:12:21.840
death date a future kill time for a sprite lifespan value is set in milliseconds. So if you wanted a sprite when you created it to stay alive for two seconds and then vanish from the game world. You could set its lifespan to 2000 and that would be two seconds.

72
00:12:23.760 --> 00:12:27.720
So all of these exists and lifespan as properties we can work with.

73
00:12:29.040 --> 00:12:39.540
The kill and the reset methods as commands we can call to apply to us. Right. These give us this ability to work with object pooling in a very efficient way.

74
00:12:39.990 --> 00:12:48.780
So that we can manage a large cast of sprites with having to add new sprites during gameplay. That's really, I guess the fundamental takeaway.

75
00:12:49.200 --> 00:13:02.130
You want to prepare a pool of sprites in the Create state before gameplay has begun, and then simply manage their existence, if you will, in the game world through

76
00:13:03.540 --> 00:13:23.250
Kill and reset through things like lifespan and exists that can happen in the update loop quickly and efficiently adding new sprites and update loop is a time and memory killer. It will suck your games responsiveness down into the pit of slow molasses.

77
00:13:28.170 --> 00:13:36.900
So before I do the review, which is where we're headed. Next, let me hop over to my cloud nine workspace and I'll fire up a folder here today.

78
00:13:38.160 --> 00:13:39.480
For module 11

79
00:13:45.810 --> 00:13:51.600
And I'll borrow my JS folder here in my assets folder duplicate them from last week.

80
00:14:01.080 --> 00:14:01.920
rename them.

81
00:14:07.230 --> 00:14:08.190
Duplicate my

82
00:14:09.870 --> 00:14:13.590
Bill your game from last week to just to get some basic starting code here.

83
00:14:15.390 --> 00:14:16.440
This guy particle demo.

84
00:14:21.420 --> 00:14:24.090
Duplicated this because I don't want to have to write

85
00:14:29.430 --> 00:14:40.020
We have to be the basic rapper code to get a game started here, but I will load up the Fazer library like usual. Like I did already in this predefined code and I'll build the game.

86
00:14:42.150 --> 00:14:58.950
Now this guy. I'm going to simplify. I'm just going to worry about the spacebar and also going to worry about this thing that a particle system needs known as an emitter, which has a coordinate in the game area. It's not visible. Usually, but it does need to be available.

87
00:15:01.980 --> 00:15:05.340
And I'll go ahead and preload. The seven or eight

88
00:15:06.990 --> 00:15:08.880
Game assets. I had in my billiard game.

89
00:15:10.260 --> 00:15:20.580
Let's see black and blue, brown and green that's eight I got eight different assets loaded here or prefixed in their asset key name with the word ball and then a color.

90
00:15:22.200 --> 00:15:26.370
Not going to remember that. So I'm going to change these all in their asset keys, just to

91
00:15:27.450 --> 00:15:28.200
Collection of

92
00:15:32.160 --> 00:15:37.200
Assets all one through eight will get them here worry about the color.

93
00:15:39.450 --> 00:15:46.170
Use these, as I said, as a group on array for my emitter. So now I've got

94
00:15:48.030 --> 00:15:51.840
Eight different ball game assets loaded ball one through eight

95
00:15:53.460 --> 00:16:04.740
And in the preload code. I'll go ahead and keep the background color, and I'll keep the physics engine turned on p two for kicks can't hurt to do all that. Then I'm going to delete all the rest of this code.

96
00:16:09.720 --> 00:16:11.070
I'll get rid of the sound effect to

97
00:16:12.630 --> 00:16:22.440
Do you want to watch when the spacebar gets press the spacebar getting press is going to be the trigger for my particle system to start emitting particles.

98
00:16:25.920 --> 00:16:27.060
So let's define

99
00:16:29.460 --> 00:16:31.950
An emitter or a particle system.

100
00:16:34.260 --> 00:16:43.290
And the emitter is covered in the phase or see documentation. So you can look there if you want more information. There's also quite a few examples.

101
00:16:43.800 --> 00:17:02.400
Of particle systems use for p two, or for Fazer addition to community edition up in phase or.io is example. So be sure to check those out. Also, I'll give you the basics of getting an emitter to work. So I define my variable called emitter up there as a global variable.

102
00:17:03.570 --> 00:17:21.570
What go ahead and assign him a value. Now to gain an emitter now an emitter takes a collection of arguments to be properly defined. Let's talk about what we do when we add an emitter. We need an X coordinate

103
00:17:23.340 --> 00:17:28.350
Need a y coordinate. So the first two things. So let's see. How big did I make this game.

104
00:17:30.360 --> 00:17:31.170
Let's just make it

105
00:17:32.430 --> 00:17:33.810
600 wide.

106
00:17:35.880 --> 00:17:37.050
300 tall.

107
00:17:38.130 --> 00:17:57.000
And so I'll place the sky smack in the middle so 300 come on comma 150 so I got my x and y coordinate for the emitter established I can move the emitter around later on. But I'm going to leave that. And then I need to tell it how many articles.

108
00:17:59.550 --> 00:18:00.390
It can emit

109
00:18:01.980 --> 00:18:07.740
With 200 for fun and grand effect. So that's a lot of particles.

110
00:18:09.420 --> 00:18:12.540
That's the basic setup for the emitter

111
00:18:14.340 --> 00:18:16.920
Now let's call it. Step one.

112
00:18:22.050 --> 00:18:24.360
Is to associate

113
00:18:27.540 --> 00:18:28.320
Assets.

114
00:18:30.450 --> 00:18:31.230
As particles.

115
00:18:34.320 --> 00:18:41.610
We would assign an asset to a sprite, we can assign assets to the emitter

116
00:18:45.540 --> 00:18:59.940
You're going to tell it now through the make particles method that we want to associate an array of asset keys and so noticing inside the ground parentheses. I'm going to pass it a single argument.

117
00:19:03.150 --> 00:19:06.120
One are an array of assets.

118
00:19:10.140 --> 00:19:14.550
Strings right so we know I've got ball one

119
00:19:18.060 --> 00:19:18.780
Ball to

120
00:19:21.270 --> 00:19:22.050
All three

121
00:19:24.960 --> 00:19:35.370
To start with, so we got four different assets. Now in the array of available visuals to us for our emitter

122
00:19:38.520 --> 00:19:42.210
Now we can also apply gravity to the emitter

123
00:19:46.950 --> 00:19:50.790
Also set transparency on the particles.

124
00:19:53.010 --> 00:20:05.040
I'll give him a range and from one which is 100% opaque to zero which is fully transparent and 3000 as an amount of time to reverse those values.

125
00:20:06.540 --> 00:20:23.580
Can also set the scale on them. Again, this is a range will go 0.5 to zero and 0.5 to zero because again we're saying scale range for the X and the Y scale and again and amount of time for those to travel those. So setting alpha and scale.

126
00:20:34.800 --> 00:20:36.060
Particles will be animated

127
00:20:40.080 --> 00:20:41.610
This range of alpha

128
00:20:44.250 --> 00:20:45.480
In this range of scale.

129
00:20:46.560 --> 00:20:51.180
So that's basically what we can do in create to prepare the emitter

130
00:20:52.590 --> 00:20:58.410
Now when the spacebar gets pressed in the sky. Let's go ahead and delete all the rest of this junk here.

131
00:21:01.380 --> 00:21:06.840
So we have a very simple update loop there is our update loop if the spacebar is pressed

132
00:21:12.210 --> 00:21:13.500
We will emit particles.

133
00:21:16.350 --> 00:21:16.980
So,

134
00:21:18.420 --> 00:21:19.890
To get an emitter going

135
00:21:21.960 --> 00:21:24.420
We can say emitter start

136
00:21:32.820 --> 00:21:38.310
And there's a few arguments we can set with the start method for an emitter

137
00:21:41.490 --> 00:21:43.920
So let's document those

138
00:21:53.040 --> 00:21:57.900
So the first thing we could tell it is a Boolean should all particles.

139
00:21:59.250 --> 00:22:03.360
Come out at once. Oh, happy explode.

140
00:22:05.760 --> 00:22:12.870
A true to start off with, and see what that looks like. And we can play by changing that to fall and see her changes a particle system.

141
00:22:14.070 --> 00:22:16.320
Then we can set a lifespan.

142
00:22:17.730 --> 00:22:20.490
each particle in milliseconds.

143
00:22:21.930 --> 00:22:23.460
Let's go for one and a half seconds.

144
00:22:27.780 --> 00:22:28.830
Anything we can do

145
00:22:31.980 --> 00:22:36.780
For using the burst or explode mode, it's going to be ignored. So we'll set it to know

146
00:22:43.470 --> 00:22:45.150
In our fourth property.

147
00:22:48.180 --> 00:22:51.060
How many particles will be emitted in a single burst.

148
00:23:07.170 --> 00:23:11.700
Let's see what happens with this much of this guy baked into

149
00:23:24.540 --> 00:23:28.260
There we go. I had to reset my zoom level very zoomed in.

150
00:23:29.790 --> 00:23:32.100
Let's see if we got anything going on with this preview here.

151
00:23:44.310 --> 00:23:53.460
There we go. So hit the spacebar and you see these guys popping out of that position where the emitter is at

152
00:23:54.690 --> 00:23:57.330
And we're spinning out, it looks like about 100 of those

153
00:23:58.680 --> 00:24:00.570
And let's play with some of these variables. Now,

154
00:24:01.650 --> 00:24:03.060
Arguments that we can manipulate

155
00:24:07.170 --> 00:24:08.850
Number particles admitted for a second.

156
00:24:20.670 --> 00:24:21.600
Negative gravity.

157
00:24:26.610 --> 00:24:29.190
So notice the gravity pulls the particles away.

158
00:24:32.460 --> 00:24:33.480
Gravity of zero.

159
00:24:41.850 --> 00:24:53.190
Again, you don't have to apply gravity to particle system. This gives you the kind of the most balanced bursting notice there's a lot of randomization going on, which sprites are being used, or excuse me, which assets are being used.

160
00:24:53.820 --> 00:24:59.370
And their velocity and the way they're traveling and the alpha that they go through

161
00:25:00.930 --> 00:25:05.850
And the scale that they go through they shrink thanks to that scale being diminished over time.

162
00:25:10.470 --> 00:25:12.060
Now we can affect other things.

163
00:25:15.150 --> 00:25:18.030
We can also set in emitters particle speed.

164
00:25:23.070 --> 00:25:26.430
And working with the main emitter object, we can see

165
00:25:28.020 --> 00:25:28.800
Particle

166
00:25:30.630 --> 00:25:31.410
Speed

167
00:25:35.790 --> 00:25:38.490
And we can set that in x and y.

168
00:25:40.890 --> 00:25:44.160
We can also set the maximum particle speed.

169
00:25:46.080 --> 00:25:47.520
Also an x and a y

170
00:25:57.240 --> 00:26:01.410
Darn zoom bar always gets in the way there. Let's get him out of the way.

171
00:26:04.230 --> 00:26:04.530
Bar.

172
00:26:08.310 --> 00:26:09.390
Did I write a typo.

173
00:26:11.340 --> 00:26:12.570
Time to look in the console.

174
00:26:18.570 --> 00:26:19.890
Oops, I forgot the set method.

175
00:26:20.910 --> 00:26:26.040
My bad. So particle speed needs a set method associated with it. So dots set

176
00:26:30.180 --> 00:26:31.680
This is not a method by itself.

177
00:26:36.060 --> 00:26:38.070
If you can see how dramatically different.

178
00:26:39.870 --> 00:26:42.840
Things get if we start to manipulate things like the particle speed.

179
00:26:44.730 --> 00:26:45.810
And a question. Yes.

180
00:26:49.590 --> 00:27:02.010
Yeah, absolutely. I your question will about attaching emitter to a sprite like a for a spaceship or something. Definitely, definitely possible. If you place the emitters x and y coordinates.

181
00:27:02.610 --> 00:27:07.800
In line with your Sprite, you basically have quote unquote attached it just move the emitter around

182
00:27:09.030 --> 00:27:15.090
In the game world to match the placement of the sprite and realize that the emitter. It is a separate object.

183
00:27:16.110 --> 00:27:24.570
From the sprite, but by default the emitter itself is invisible. So for example, let's take a quick look. And I'll share this this week.

184
00:27:29.010 --> 00:27:44.250
At some student work from previous semesters. And so these are some links to games that students have created in past semesters using both Fazer and the Unity engine and here this game exile, which

185
00:27:45.810 --> 00:27:55.140
Might take a moment to load, because then it could have some audio associated with it. It uses a particle system to create the flame coming out of the back of the spaceship.

186
00:28:01.740 --> 00:28:04.800
Hopefully it's gonna finish loading. I think, again, it's got a big audio file.

187
00:28:10.590 --> 00:28:14.670
Little green plane to tailor the spaceship is in the military.

188
00:28:22.350 --> 00:28:23.520
So definitely doable.

189
00:28:24.720 --> 00:28:37.890
And really particle systems lend themselves to that kind of simulation of real world effects like flames and explosions fire and smoke really well. It's what they're typically used for an animation and in game development.

190
00:28:45.600 --> 00:28:46.350
So,

191
00:28:47.730 --> 00:29:00.450
I'd like to with our time available today shift my focus now to looking back a bit and talking about what we've covered so far we've been together for 10 weeks already

192
00:29:01.530 --> 00:29:08.490
10 different modules and material mostly focused on two things JavaScript and

193
00:29:09.510 --> 00:29:10.560
The phase or game engine.

194
00:29:12.090 --> 00:29:15.510
Now wrapped up in that is also some general concepts.

195
00:29:16.560 --> 00:29:23.700
About game engines generally in video game development that are covered. And so to

196
00:29:24.750 --> 00:29:26.490
Prepare for this midterm exam.

197
00:29:27.690 --> 00:29:37.800
In which there are only 14 questions selected from a randomly from a larger set of questions that you might get you'll have two hours to tackle.

198
00:29:38.850 --> 00:29:40.440
Three major topic areas.

199
00:29:43.140 --> 00:29:49.650
JavaScript programming basics game programming concepts and the phase your library itself.

200
00:29:52.290 --> 00:29:58.140
So the things that get covered in JavaScript programming basics are just essential

201
00:29:59.910 --> 00:30:07.830
control structures and declarations like creating variables that we need to be able to pull off to

202
00:30:09.690 --> 00:30:21.120
Build the mechanics for basic video game. So the idea of variables. The data types of both arrays and object values which are heavily used in the phase or engine.

203
00:30:22.500 --> 00:30:35.340
The use of dot notation to access individual property values inside an object or to call a method of an object to call a functional block code stored in objects and conditions and loop. So those are the key.

204
00:30:36.690 --> 00:30:39.930
Aspects of the JavaScript language that you should be comfortable with.

205
00:30:59.400 --> 00:31:00.780
JavaScript just for a second.

206
00:31:06.240 --> 00:31:10.350
Do this without worrying about the engine need to know about variables.

207
00:31:14.430 --> 00:31:16.140
Variable outside

208
00:31:21.600 --> 00:31:24.120
Of any function gives it global scope.

209
00:31:25.410 --> 00:31:26.340
Keep that in mind.

210
00:31:28.500 --> 00:31:29.130
Variable

211
00:31:30.570 --> 00:31:31.710
inside a function

212
00:31:33.660 --> 00:31:38.430
Makes it a local variable. And when I say declaring we use the bar statement.

213
00:31:40.110 --> 00:31:42.960
Statement to declare a new

214
00:31:44.370 --> 00:31:45.060
Container

215
00:31:46.260 --> 00:31:46.800
Variable

216
00:31:52.410 --> 00:31:57.900
Define a variable called my local inside my code and then I call my code.

217
00:31:58.920 --> 00:32:03.570
And I try and log to the console my local variable.

218
00:32:13.020 --> 00:32:19.080
We pop this guy open into a new browser window and we go look in the console.

219
00:32:20.550 --> 00:32:27.750
See what console log. I'm getting an error, my local is not defined. It tells me online 19 in my code.

220
00:32:28.920 --> 00:32:30.330
And that is true. You can see

221
00:32:32.940 --> 00:32:44.640
Cloud nine caught that error two variables that are declared with a var statement or let statement inside of the curly braces of a function are only available inside that function.

222
00:33:01.980 --> 00:33:04.050
curlies here. So inside of here.

223
00:33:07.140 --> 00:33:08.220
I'm sold out log

224
00:33:10.770 --> 00:33:15.510
My local variable totally will work. And notice I'm not getting an error and Cloud nine either here.

225
00:33:17.340 --> 00:33:25.530
Boom. It spits out five because within the curlies that variable scope is available after the curlies. Nope. No dice.

226
00:33:28.380 --> 00:33:33.450
If we want to set a pre existing

227
00:33:35.040 --> 00:33:36.750
Global variables value.

228
00:33:39.630 --> 00:33:41.550
Sign a new value.

229
00:33:43.470 --> 00:33:43.890
Out.

230
00:33:46.110 --> 00:33:54.930
Using bar or let again if I want to change my global just say my global equals don't say bar again now.

231
00:34:02.850 --> 00:34:04.020
When I run that code.

232
00:34:05.520 --> 00:34:17.070
I've changed my global. And I did that change inside the current release of a function that's okay as long as the variables declared before the curlies before the function, you are good to go.

233
00:34:21.150 --> 00:34:25.800
Now, creating object values and reading object values.

234
00:34:30.300 --> 00:34:42.240
Good thing to know how to do. And of course Fazer creates a huge number of object values for us when we define our game when we find any sprite returns to our variables a curly braces object structure that includes properties.

235
00:34:46.200 --> 00:34:47.250
That can have values.

236
00:35:01.290 --> 00:35:01.920
Variable

237
00:35:05.910 --> 00:35:12.090
Curly braces object structure to it with property names, you can use dot notation to access those properties.

238
00:35:14.820 --> 00:35:16.920
So if I have this variable called My object.

239
00:35:19.650 --> 00:35:24.900
And I want to access the value stored in the property named my property. I use dot notation.

240
00:35:33.360 --> 00:35:34.170
Property

241
00:35:45.180 --> 00:35:58.230
So boom that alert spits out the text that stored in my property. It's inside my object by using that dot notation syntax. My object.my property so

242
00:35:59.940 --> 00:36:02.280
Basically every period.

243
00:36:05.850 --> 00:36:06.930
Signifies

244
00:36:19.080 --> 00:36:31.350
We've crossed into. So if I write my object. And I want to get to my property. Well, there's one curly brace between the two of those guys. So when I write the dot notation and basically right my object.my property.

245
00:36:32.250 --> 00:36:39.870
Now in Fazer we've seen cases where there are many dots and dot notation syntax and that is because

246
00:36:42.000 --> 00:36:43.950
We can have other object values.

247
00:36:47.670 --> 00:36:54.660
For themselves as curly braces objects inside of a property. So if I have a property called object bow.

248
00:36:58.140 --> 00:36:59.190
And inside him.

249
00:37:00.990 --> 00:37:02.190
Creates more properties.

250
00:37:11.430 --> 00:37:15.240
Notation to access that inner nested object value.

251
00:37:21.450 --> 00:37:40.920
So again, every time I cross curly I put a.in the dot notation. So to get from my object down to object Val. There's one curly in the way. So I write my object dot object Val, then I see the object Val itself as a curly braced

252
00:37:42.690 --> 00:37:57.690
Object value stored in it. And so to get inside of there. There's another curly to cross. So I read another dot and then I write the property name. So my object object Val second should retrieve the phrase monster using dot notation.

253
00:38:01.260 --> 00:38:01.920
There he is.

254
00:38:03.900 --> 00:38:04.620
Monster.

255
00:38:06.030 --> 00:38:06.960
Fabulous.

256
00:38:08.100 --> 00:38:18.570
So working with object values something you've implicitly been doing working Fazer and we talked about it a long time ago. We even did it when we played code combat.

257
00:38:19.890 --> 00:38:25.740
Hero dot move left well there you're executing a method on the object of hero.

258
00:38:31.860 --> 00:38:33.180
And conditional statements.

259
00:38:35.370 --> 00:38:38.490
Statements, if you will, are critical to us.

260
00:38:39.780 --> 00:38:43.200
We could ask a question about if my global is greater than 10

261
00:38:49.470 --> 00:38:50.010
On the screen.

262
00:38:51.600 --> 00:38:58.530
We do that with an if statement inside parentheses, we make a comparison. And if the answer is true.

263
00:39:06.990 --> 00:39:09.150
We can also have an optional else clause.

264
00:39:21.000 --> 00:39:29.940
Interest also optional else block would only run if that condition that we test their sales and gives us back a false

265
00:39:36.240 --> 00:39:40.290
We get that big number spit out there because if evaluated is true.

266
00:39:47.040 --> 00:40:03.750
Variables arrays object values dot notation conditional some loops are the critical things to be comfortable with inside of JavaScript to work efficiently in the language. So the last thing I'll mention here are raised and loops an array variable.

267
00:40:05.580 --> 00:40:07.920
Is a list of values contained in square braces.

268
00:40:13.110 --> 00:40:15.720
Now I could write a loop using the four

269
00:40:17.040 --> 00:40:18.480
Statement in JavaScript.

270
00:40:23.010 --> 00:40:23.580
Each

271
00:40:24.720 --> 00:40:25.170
Value.

272
00:40:26.640 --> 00:40:30.630
In our array, if we want to loop through each of those four takes

273
00:40:31.680 --> 00:40:32.160
The

274
00:40:33.180 --> 00:40:39.180
Setup expressions we define a counter variable and the first thing

275
00:40:42.330 --> 00:40:42.810
We

276
00:40:44.550 --> 00:40:49.050
Have a condition test whether to run loop again.

277
00:40:50.190 --> 00:40:57.450
For. Second thing. The third thing is operation to perform on counter variable.

278
00:40:59.010 --> 00:41:08.280
Here in the first thing I could say bar i equals 00. Now, I could say if i is less than the number of elements.

279
00:41:09.780 --> 00:41:25.680
In our array by using the length property have any array variable. It has a property that we can write using dot notation. So array dot length for this particular collection of values that are defined in my variable Maya re will give me back a number four.

280
00:41:27.090 --> 00:41:34.410
And I could say I equals i plus one. Or I could write it condensed is the increment operator just say i plus plus.

281
00:41:35.640 --> 00:41:38.160
And in that way, I could have

282
00:41:42.180 --> 00:41:48.720
output to the console as a demo individual values individual elements from that list of

283
00:41:50.310 --> 00:42:01.350
Values in my array by using a range notations square brackets and a number I can retrieve each individual element by its index position by where it sits

284
00:42:02.280 --> 00:42:11.340
Potentially in the race. So my array zero will give me back the number five, because that's the first element my array square brackets one will give me back the value 10

285
00:42:12.630 --> 00:42:17.730
So in this way, we can move through and work with all the values in an array.

286
00:42:19.080 --> 00:42:24.540
So here's the output from that move if walk through each value in my array.

287
00:42:30.660 --> 00:42:40.080
Now we've seen as well Fazer has a method called for each that that you walk through each Sprite in a group. It's basically a loop construction of its own.

288
00:42:41.970 --> 00:42:48.960
Working with basic JavaScript control structures variables conditional loops.

289
00:42:50.040 --> 00:43:00.180
And these two data types of an array and an object value. Those are the bread and butter of JavaScript programming for game engines like Fazer

290
00:43:07.230 --> 00:43:14.430
The game programming concepts we've covered are very well articulated in our textbook reading, I'll say just a little bit about them now.

291
00:43:15.480 --> 00:43:26.280
Being familiar with the terminology of assets and sprites sprites being game objects that are game engine pays especially close attention to, to detect things like collisions.

292
00:43:27.870 --> 00:43:35.640
The ability to tweet or to move a game object of Sprite between two locations and transform it over time.

293
00:43:36.780 --> 00:43:41.760
Idea that the players view in the browser. The rendered visual

294
00:43:43.110 --> 00:43:50.790
Of the game is determined by the games camera that is watching the game play. It's an important concept to have strayed

295
00:43:51.330 --> 00:43:58.230
The idea that we can only work with physics engine properties on a sprite by referring to that sprites body.

296
00:43:59.010 --> 00:44:07.080
And that physics considers the sprite with this extra attribute of suddenly having a physical body in the world that

297
00:44:07.830 --> 00:44:17.070
can manipulate and that can be responded to by other objects and collisions. The idea that all the game objects in our world.

298
00:44:17.850 --> 00:44:37.470
Live in a display list. It's basically a big array of objects that refresh. Each time the game loop is executed in our world, the states of Fazer preload CREATE AN UPDATE GIVE US A path to preload assets to create sprite.

299
00:44:38.610 --> 00:44:55.290
And then in the update game loop to manage their collisions there tweens. Are they on camera. Do we have a physics engine enabled, and if so, how does their body get affected by it. So game programming concepts. I think you'll find

300
00:44:56.580 --> 00:45:03.510
Easy to recall through a very simple review of the chapters that we've covered in our book.

301
00:45:04.980 --> 00:45:11.730
And if you've got more interest in this and this is well beyond the scope of was asked in the midterm. So don't worry about this.

302
00:45:12.480 --> 00:45:20.880
If you want to focus purely on the midterm and its scope, but when you get done with the midterm exam and you're wondering, you know, how does the game engine really work.

303
00:45:22.320 --> 00:45:31.440
Check out this great article by Harold Serrano that unpack with a developer's mind how a game engine really works.

304
00:45:33.150 --> 00:45:43.080
And he does a great job of walking through the different components of the software that is Fazer and also unity3d and

305
00:45:44.220 --> 00:45:51.600
Unreal Engine and game maker all these different tools that we use to make games they all have inside of their code.

306
00:45:52.110 --> 00:46:04.770
These functionalities that are described by Harold Serrano in this short article. How does a game engine work. So I invite you to check that out. It's got some great details, give you a better sense of how game engines really work.

307
00:46:10.920 --> 00:46:19.290
The third section of the midterm exam again pretty simple. We've been working with Fazer we see the pattern now of how to make a Fazer based game.

308
00:46:19.770 --> 00:46:29.100
And fundamental that are those states, I just mentioned the idea that the phase or engine loads blocks of our code in our coding pattern to date by simple functions.

309
00:46:29.580 --> 00:46:50.850
That are reflected back into its state based model of pre loading then creating and then going into the game loop where update and render are called over and over again so that we can do debugging and rendering of our gameplay and we see that all the time.

310
00:46:52.830 --> 00:46:53.790
In our code.

311
00:46:55.830 --> 00:46:57.060
When we create the game.

312
00:46:58.350 --> 00:47:03.840
So every time we make a new game object from a phase or game template.

313
00:47:04.920 --> 00:47:20.430
We're telling it as the last argument we pass it in an object value what the names of the functional blocks of code or that it should use for its preload. It's create its update and its render which is optional.

314
00:47:21.600 --> 00:47:39.630
States. Remember update and render always run in the game loop over and over again so update and render are being repeated as gameplay happens over time preload runs once. And the very first thing that happens, create runs after preload and then the update and render game loop start

315
00:47:44.700 --> 00:47:53.280
Remember the concept of spreadsheets. It's a specific implementation and Fazer but it's a general concept that many game engines support, including unity.

316
00:47:54.000 --> 00:48:08.490
And Unreal Engine idea that we could combine many bit maps for different frames for an individual sprite into a single graphic and then we can define the dimensions of each of those frames.

317
00:48:10.380 --> 00:48:24.300
Remember the concept of input, the ability to look at the keyboard or to get data from the mouse point pitcher all conducted in phase or through this master input game object.

318
00:48:25.380 --> 00:48:32.130
Think about how audio works, how do you get an A sound to start. Once you pre loaded its asset.

319
00:48:33.930 --> 00:48:42.000
And have some comfort to with this idea that we talked about today of pooling and lifespans. The idea that you can kill and reset.

320
00:48:42.330 --> 00:48:55.470
sprites that you've already defined so you don't have to create the sprites during the update loop, but instead you can make a big sprite pool during the Create state of any game that you can then reuse over and over again.

321
00:48:57.900 --> 00:49:00.570
This is the terrain of the midterm exam this week.

322
00:49:04.530 --> 00:49:13.980
And you can see here the midterm available to you towards 70 points and it's not due until next Thursday night, November 8

323
00:49:22.170 --> 00:49:26.280
So in addition to this being the week where we

324
00:49:27.300 --> 00:49:37.530
Reflect back on where we've been in the past 10 weeks. It's also the week. We're kind of at the top of the peak here of knowledge that we can have acquired about Fazer

325
00:49:38.130 --> 00:49:48.000
And now we can see the lay of the land, we've seen many Fazer game examples. Again, I got examples of student final projects that I'll share with you in

326
00:49:49.350 --> 00:49:50.400
Canvas this week.

327
00:49:52.170 --> 00:50:03.060
To get through the journey of building a final project for this class. There are three major steps to success. The first is just having an idea.

328
00:50:03.900 --> 00:50:10.080
And this assignment this week, the draft game design document really ask you just to articulate your idea.

329
00:50:11.070 --> 00:50:20.220
As a draft. It's not your final commitment, you'll have another chance in two weeks to develop a final version of your game design document your final proposal for what you want to build

330
00:50:20.640 --> 00:50:28.620
But this week blue sky, a little bit to find something that you'd like to build it could be a game you've already started to create in our earlier.

331
00:50:29.310 --> 00:50:40.950
Assignments. It could be a remix a riff on a game example you found in some of the tutorials it fazer.io or in other people's sites like HTML5 game developers.

332
00:50:41.370 --> 00:50:50.220
Or the code and web folks who have many examples really the Fazer engine has hundreds and hundreds of example projects that are tutorial.

333
00:50:50.850 --> 00:50:58.170
Based all over the internet available for you and our book in chapter seven, the chapter, we haven't really touched yet.

334
00:50:58.620 --> 00:51:09.330
Is filled with a collection of example games built using an object oriented class based programming style that I'll introduce next week. And I've got all of those games.

335
00:51:10.110 --> 00:51:22.830
Working in a workspace that I've shared a link to this week so you can come in and open up any one of these games and see how it works. So let's look at their platform or, for example.

336
00:51:24.240 --> 00:51:31.350
simply do a live preview of the index file for any one of these games. So you just open it up.

337
00:51:32.370 --> 00:51:33.510
Do a live preview.

338
00:51:37.560 --> 00:51:38.970
And the game will load.

339
00:51:40.050 --> 00:51:42.450
And you can play any one of these example games.

340
00:51:44.970 --> 00:51:51.000
These games are available. The code is in the book and annotated by the author of a book.

341
00:51:52.380 --> 00:51:58.590
So you can see exactly how he built these games with a lot of support. And so those games are available as well.

342
00:51:59.640 --> 00:52:03.540
For you to consider re mixing as your final project.

343
00:52:09.960 --> 00:52:15.030
Next week, everybody will have a chance to look at each other's game design documents.

344
00:52:16.050 --> 00:52:25.290
Again, these are just Google Docs or Microsoft Word or PDF files that you'll create and submit for week 11 in the draft form now.

345
00:52:26.130 --> 00:52:37.800
This assignment, the draft and the final game design documents they represent two assignments that are worth individually 100 points each. So there's no coding requirements for these, these are

346
00:52:39.600 --> 00:52:44.220
Design and vision documents where you're articulating what you want to do.

347
00:52:50.430 --> 00:53:00.120
And then we'll go in to a process of building these games over the last month with weekly build and take play test sprints where other students can look at each other's works.

348
00:53:03.720 --> 00:53:15.660
So this week, your challenges are simple take the midterm exam. After you've done some review of our materials. If you've been keeping up with the homework assignments. You are well positioned to

349
00:53:16.740 --> 00:53:25.770
Have an excellent score on the midterm exam if you're behind on some homework assignments. Do the review anyway and take the exam. You can turn in your homework assignments later on.

350
00:53:27.510 --> 00:53:34.800
And then turn your attention towards this world of game design documents so you can get a handle on what it takes to build one

351
00:53:36.390 --> 00:53:42.750
And we've got great resources for that this week. If you look at the exam at the assignment, you'll see

352
00:53:44.970 --> 00:53:56.640
A link on designing your first game again the concept of a minimum viable product, also called an MVP, not to be confused with most valuable player, but the minimum viable product.

353
00:53:57.120 --> 00:54:03.750
Is really where you should focus your attention and the rest of the semester, do not plan on building an entire version of fortnight.

354
00:54:04.530 --> 00:54:12.390
Or Assassin's Creed in the time we have left. Imagine that you can prototype. The gameplay for a fun and engaging game.

355
00:54:12.960 --> 00:54:22.050
In the time we have left. And so, set your sights on the minimum that you think it takes to be successful. So check out that extra credits video helps you set your expectations. Right.

356
00:54:23.130 --> 00:54:29.160
And then check out the article from Bender waffles. It's only five minutes long as video called What is a game design document.

357
00:54:31.140 --> 00:54:40.770
And then we have friends at trick gaming studios. They've given us a template and they walk us through how to write a game design document.

358
00:54:48.450 --> 00:55:00.810
They will walk you through every section of the template that we are using which is their template. It's linked in this week's assignment and they'll walk you through all the sections of that template step by step.

359
00:55:01.830 --> 00:55:06.720
So again to get your head around preparing for what you want to build check out

360
00:55:07.590 --> 00:55:26.610
The game examples from Chapter seven in the workspace that I'm linking to here. I'll put it in Canvas as well check out past students game projects. You can see them a collection of them. I think there's let's see 2456 810 there's 10 games here that you can play from past semesters.

361
00:55:28.650 --> 00:55:38.670
Or look around the world of the internet where dozens and dozens of Fazer game examples exist that you can remix and riff off of and be inspired by

362
00:55:42.750 --> 00:55:50.820
Check out trick gaming studios article on how to write a game design document, you can download their templates straight off our assignment this week and Canvas.

363
00:55:51.180 --> 00:55:58.380
And you'll see it basically is an eight point outline where you can talk about in little chunks like a paragraph and each chunk.

364
00:55:59.700 --> 00:56:01.440
Exactly how your game is going to work.

365
00:56:02.790 --> 00:56:11.190
This is your draft screenplay, if you will, if you think about a game as a film as an interactive experience that people can engage in

366
00:56:11.670 --> 00:56:28.320
Just like a film a game has a cast of characters potentially a scenario, a world to define goals challenges all those game aesthetics that we talked about when we were thinking about mechanics dynamics and aesthetics. They can all be expressed in your game design document.

367
00:56:34.260 --> 00:56:38.190
And that's enough for everybody already to tackle this week.

368
00:56:39.480 --> 00:56:39.990
If

369
00:56:42.570 --> 00:56:52.890
You want more. And this isn't if this is an extra credit opportunity for the next seven weeks. Weeks 11 through 17 the last regular week of our semester.

370
00:56:53.400 --> 00:57:02.850
I will be providing in a separate part of each weekly module materials to introduce the Unity 3D game engine a completely different game engine than Fazer

371
00:57:03.390 --> 00:57:13.770
One that once worked with JavaScript, but now no longer works with JavaScript relies on the C sharp language, which is another high level scripting language, similar to JavaScript, but different.

372
00:57:15.540 --> 00:57:20.070
And this extra credit material is for people who are comfortable coding

373
00:57:21.870 --> 00:57:28.470
Unity 3D environment will require you to do coding it does have a number of other differences as an environment, however.

374
00:57:29.220 --> 00:57:36.840
unity3d is a complete desktop application that represents an integrated development environment. It is an authoring software program.

375
00:57:37.380 --> 00:57:53.910
So unlike Fazer which is simply a code base that we have to load and then we construct our entire game code unity gives you a graphical user interface for manipulating your game world and working with sprites and game assets, all in one integrated environment.

376
00:57:55.110 --> 00:58:03.000
For that reason, it's a big, complex terrain to cover and this is purely extra credit opportunity to look at unity3d in our class.

377
00:58:04.320 --> 00:58:12.780
So check it out if you want. You'll see each week from now on when we look at the high level module for week 11 a section labeled extra credit

378
00:58:18.180 --> 00:58:25.350
And there's extra materials there and there's also in each week an extra credit assignment available if you dive in.

379
00:58:26.820 --> 00:58:34.710
Now, if you're hungry for extra credit points I will let on that this first week is really just about getting unity installed to look around in it.

380
00:58:35.190 --> 00:58:43.560
And so if you want 10 points extra credit for whatever reason, getting through this week's extra credit work around unity is simple. There's no coding required

381
00:58:53.910 --> 00:58:56.370
So what to do next. Well,

382
00:58:59.070 --> 00:59:06.960
Check out the last 10 pages of Chapter six to get a familiarity with some of the advanced capabilities of the Fraser engine.

383
00:59:07.800 --> 00:59:25.740
What we looked at today. We're particle systems and I talked extensively about object pooling and the kill and reset methods as well as the exists and lifespan properties that are available to you to take sprites out of the game world, but keep them available in memory.

384
00:59:27.960 --> 00:59:32.130
Assignment 11 really does walk you in to the

385
00:59:33.390 --> 00:59:46.470
Process of articulating a vision a blueprint a plan for a game that you want to build. Remember, this is a draft, it's worth 100 points, please do this assignment, you'll have a chance to revise it and week 13

386
00:59:46.920 --> 00:59:53.040
And you'll get another hundred points, then if you complete these so tackle that work. It's important to tackle.

387
00:59:54.600 --> 00:59:58.680
Not wait too long. We'll run at a time to build a game. If we don't all get started now.

388
01:00:00.030 --> 01:00:12.420
And the midterm exam 14 questions covering JavaScript in the phase or game engine basic game concepts I expect all of you who've been making your way through the homework will do very well on the midterm.

389
01:00:14.250 --> 01:00:22.650
And that's everything there is to do so. Thanks for joining me today. If you've got questions about anything. As always, jump into Canvas. We've got weekly

390
01:00:23.100 --> 01:00:33.780
Sharing support discussions. I'm going to start encouraging people more and more to share their game and progress work so that everybody can be inspired by each other's work as we go into the final stretch here.

391
01:00:34.980 --> 01:00:37.380
So I'll see you online. Thanks for joining me today.

